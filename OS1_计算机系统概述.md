## 基本概念

<u>**计算机硬件基本组成（冯 · 诺依曼模型）**</u>

主机部分：运算器、存储器、控制器。

外设部分：输入设备、输出设备。

<u>**操作系统 OS (Operating System)**</u>

计算机系统中最基本的系统软件。

控制和管理整个计算机系统的软硬件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。

<u>**操作系统的特征**</u>

1. 并发(concurrence)

   指两个或多个事件在**同一时间间隔**内发生。

   体现在操作系统中是指其具有处理和调度多个程序同时执行的能力。

   > 并行性：指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。
   >

2. 共享(sharing)

   资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

   方式：互斥共享（临界资源）、同时访问（宏观）。

   :sun_with_face:**并发**和**共享**是操作系统**最基本特征**，两者互为存在的条件。

3. 虚拟(virtual)

   指将一个物理上的实体变为若干逻辑上的对应物。

   虚拟技术：用于实现虚拟的技术。

   操作系统的虚拟技术可归纳为：时分复用技术（如虚拟处理器）、空分复用技术（如虚拟存储器）。

4. 异步(asynchronism)

   多道程序环境中，由于资源有限，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性。

   异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（进程的推进顺序不当）。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。

<u>**引入操作系统的目的**</u>

有效地控制和管理计算机系统中的各种硬件和软件资源，使之得到更有效的利用。

提供一个计算机用户与计算机硬件系统之间的接口，使计算机系统更易于使用。

合理地组织计算机系统的工作流程，以改善系统性能。

<u>**操作系统的基本功能**</u>

<u>一、作为计算机系统资源的管理者</u>

1. 处理机管理/进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。
2. 存储器管理：内存分配与回收、地址映射、内存保护与共享、内存扩充等。
3. 文件管理：文件存储空间的管理、目录管理、文件读写管理、文件保护等。
4. 设备管理（最庞杂琐碎）：缓冲管理、设备分配、设备处理、虚拟设备等。

<u>二、作为用户与计算机硬件系统之间的接口</u>

1. 命令接口

   提供一组操作命令供用户直接或间接组织和控制作业的执行。

   常见的命令接口：命令解释器、命令解析器（如 shell）。

   按作业控制方式分为：

   1）联机命令接口/交互式命令接口（适用分时或实时系统）

   由一组键盘操作命令组成。

   用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令。控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可以输入下一条命令。

   2）脱机命令接口/批处理命令接口（适用于批处理系统）

   由一组作业控制命令组成。

2. 程序接口

   由一组系统调用（又称广义指令）组成，是操作系统为应用程序使用内核功能所提供的接口，只能通过用户程序间接使用，编程人员可以使用它们请求系统服务，如使用各种外设、申请分配和回收内存及其他各种要求。

   在高级语言中常以函数形式（库函数）提供给程序员，但库函数属于用户程序而非系统调用，是系统调用的上层。另外，并非所有库函数都与系统调用有关

   图形用户界面 GUI 即图形接口也不属于操作系统，它只是为了调用系统调用而实现的功能。

   > 计组中解释的广义指令：为了扩展机器功能而设置，是由操作系统定义和解释的软件指令。

<u>三、实现对计算机资源的扩充</u>

裸机覆盖了软件便成为扩充机器或虚拟机。

## 操作系统发展历程

### 手工操作阶段（无操作系统）
存在问题：

1. 速度矛盾

   人机矛盾：手工操作的慢速与 CPU 运算的高速产生矛盾。

   CPU 与 I/O 设备之间速度不匹配的矛盾。

2. 资源利用率低

### 批处理阶段（操作系统开始出现）

#### 单道批处理系统

目标：尽量使系统连续运行。

为实现对作业的连续处理，需要先将一批作业以脱机方式输入磁带，并在系统上配上监督程序 Monitor，在其控制下，使这批作业能一个接一个地连续处理。虽然系统对作业的处理是成批进行的，但在内存中始终保持一道作业。

特点：

1. 自动性：顺利的情况下，磁带上的一批作业能自动地逐个运行，而无需人工干预。
2. 顺序性：磁带上的各道作业顺序地进入内存，先调入内存的作业先完成。
3. 单道性：内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。

优点：大大提高资源的利用率，解决人机矛盾。

缺点：

1. I/O 和 CPU 计算仍旧串行，导致 CPU 利用率低下；
2. 无交互性。

#### 多道批处理系统

目标：尽量让系统各个部分去 “忙”。

**<u>多道程序设计技术</u>**

特点：多道（内存中同时存放多道相互独立的程序）、宏观上并行、微观上串行。

基本特征：间断性、共享性、制约性（失去了顺序性、封闭性）。

需要解决：处理器分配、内存分配、I/O 设备分配、程序和数据的组织和存放（保证安全性和一致性）。

批处理作业必须提供相应的作业控制信息。

**<u>多道批处理系统</u>**

在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。

系统资源为多个作业共享，作业之间自动调度运行，实现作业自动控制。

特点：脱机操作、成批处理（监督程序负责自动调度）、多道程序运行（多作业调入内存并组织其运行）。

优点：进一步提高了系统资源利用率和作业吞吐量，使 CPU 和其他资源保持 “忙碌” 状态。

缺点：

1. 无交互性（主要缺点），用户既不能了解自己的程序的运行情况，又不能控制计算机；
2. 用户响应时间较长；
3. 需要付出额外开销来组织作业和切换作业。

> <u>多重处理</u>：使用多个 CPU，可完成真正意义上的并行。
>
> <u>多任务处理</u>：多个进程并发执行，宏观并行，单核多核都可。
>
> 2018 年真题考察的多任务操作系统可视为具有交互性的多道批处理系统。

### 分时操作系统
**<u>分时技术</u>**

把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用，给每个用户 “独占一台计算机” 的感觉。

**<u>分时系统</u>**

**实现人机交互**的系统。

目标：快速响应用户。

特点：

1. 同时性/多路性：一台计算机与若干台终端相连。
2. 交互性：用户通过终端采用人机对话的方式直接控制程序运行，与程序进行交互。
3. 及时性：用户请求能在很短时间内获得响应。
4. 独立性：及时性造成的表面效果。

进程调度：优先级 + 非抢占式。

分时系统也是支持多道程序设计的系统。

典型的分时操作系统：Unix、Linux。 

### 实时操作系统
“实时”：计算机对于外来信息能够以足够快的速度进行处理，并在**被控制对象允许的时间范围内**做出快速反应。对响应时间的要求比分时操作系统更高（比时间片的时间还短）。

特点：提供及时响应、高可靠性。

进程调度：优先级 + 抢占式。

硬实时系统：必须提供绝对保证，让某个特定的动作在规定的时间内完成，如飞行器的飞行自动控制系统。

软实时系统：接受偶尔违反时间规定且不会引起任何永久性的损害，如飞机订票系统、银行管理系统。

> 以上是操作系统的基本类型。若一个操作系统兼有两种以上的功能，则该操作系统统称为通用操作系统。

### 网络操作系统
通过通信设施将物理上分散的、具有自治功能的多个计算机互连起来，提供一种统一、经济而有效的使用各台计算机的方法，实现信息交换、资源共享、可互操作和协作处理的系统。

主要特点：网络中各种资源共享以及各计算机之间的通信。

### 分布式计算机系统
多台计算机协同合作完成一个特定任务的系统。

分布式计算机系统是由多台计算机组成并满足下列条件的系统：

1. 系统中任意两台计算机通过通信方式交换信息；

2. 系统中的每台计算机都具有同等地位，即不分主从；

3. 每台计算机上的资源为所有用户共享；

4. 系统中的任意台计算机都可以构成一个子系统，并且还能重构；

5. 任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。

主要特点：分布性、并行性。

是网络操作系统的更高级形式，它保持网络操作系统所拥有的全部功能，同时又具有透明性、可靠性、高性能等。

与网络操作系统的本质不同：分布式操作系统中的若干计算机相互协同完成同一任务，以缩短单个任务的执行时间来提升效率。

### 个人操作系统

使用最广泛，广泛应用于文字处理、电子表格、游戏中

常见个人操作系统：Windows、Linux、MacOS。

### 其他操作系统
<u>嵌入式操作系统</u>、<u>服务器操作系统</u>、<u>智能手机操作系统</u>等。

<u>集群系统(Clustered Systerm)</u>：集群中的每个节点提供的服务/功能是相同的，目的是通过提高单位时间内执行的任务数来提升效率，主要用来作**负载均衡**（而分布式是指将不同的业务/功能分布在不同的系统）。

## 操作系统运行环境

### 处理器运行模式

**<u>两种不同性质的程序</u>**

1. 操作系统内核程序。
2. 应用程序（用户自编的系统外层程序）。

对操作系统而言，前者是后者的管理者，因此 “管理程序”（内核程序）要执行一些特权指令，而 “被管理程序”（用户自编程序）出于安全考虑不能执行这些特权指令。

**<u>特权指令</u>**

指不允许用户直接使用的指令（即只能由操作系统内核部分使用）：

1. 有关 I/O 设备使用的指令

   I/O 指令涉及中断操作，而中断处理由内核负责。

2. 有关访问程序状态的指令

   如进程切换（送程序状态字到程序状态寄存器的指令）。

3. 存取特殊寄存器指令

   涉及中断寄存器、用于内存保护的寄存器、时钟寄存器等（置时钟指令是，读时钟指令不是）。

4. 其他特权指令

   如：清内存指令、存储保护指令、中断返回指令等。

**<u>非特权指令</u>**

指允许用户直接使用的指令。

不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户系统对系统造成破坏。

**<u>处理器的运行模式/执行状态</u>**

1. 核心态/管态/系统态/内核模式
   
   具有较高特权，能执行包括特权指令的一切指令，能访问所有寄存器和存储区。
   
   操作系统内核程序运行在核心态。
   
2. 用户态/目态/用户模式

   具有较低特权，只能执行规定的指令，只能访问指定的寄存器和存储区。

区分执行态的主要目的也是保护系统程序。

:warning:陷入指令/访管指令是唯一只能在用户态下执行而不能在核心态下执行的指令。

**<u>模式切换</u>**

1. 用户态 → 核心态

   发生在中断/异常产生时（**唯一途径**:warning:），由**硬件**实现（CS 寄存器中的 RPL 字段）。

   主动进入核心态：执行访管指令（发起系统调用，“自愿中断”）。

   被动进入核心态：中断/异常处理。

2. 核心态 → 用户态

   发生在中断返回用户程序时（唯一途径）。

   除了从中断处理过程返回外，任何时候 CPU 都不允许从高特权级转移到低特权级。
   
   显然中断返回指令属于特权指令。

模式切换有开销（但不属于上下文切换）。

不仅状态需要切换，而且所用的堆栈也需要由用户栈切换到内核栈。

### 操作系统内核

内核是计算机上配置的底层软件，可以看作是连接应用程序和硬件的一座桥梁。

**<u>操作系统内核构成</u>**

1. 与硬件关联较紧密的模块（操作系统最底层）

   如：时钟管理、中断处理、设备驱动

2. 运行频率较高的程序（操作系统次低层）

   如：进程管理、存储器管理、设备管理

以上是特点，不是划入内核的原因，比如进程切换主要是因为需要修改程序状态字。

**<u>内核的主要内容</u>**

大多数操作系统的内核包括以下 4 方面的内容：

1. 时钟管理

   时钟的第一功能是计时，操作系统需要通过时钟管理向用户提供标准的系统时间。

   另外可以通过时钟中断的管理实现进程切换（如时间片轮转调度）。

2. 中断机制
   
   实际上中断机制只有一小部分属于内核，它们负责保护和恢复中断现场的信息、转移控制权到相关处理程序，这样可减少中断的处理时间，提高系统的并行处理能力。
   
   引入中断技术的初衷是提高多道程序运行时的 CPU 利用率，使 CPU 可以在 I/O 操作期间执行其他指令。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。
   
   可以说现代操作系统是靠中断驱动的软件（中断是操作系统必须提供的功能）。
   
3. 原语(Atomic Operation)

   一些可被调用的底层公用小程序，各自完成一个规定的操作。

   处于操作系统（内核）最底层，最接近硬件的部分:warning:。

   程序运行具有原子性，是不被分割、不被中断执行的操作序列（出于系统安全性和便于管理考虑）。

   运行时间较短，调用频繁。

   通常可由硬件实现，或者直接关中断，在单处理机上也可由软件通过屏蔽中断方法实现。

4. 系统控制的数据结构及处理（系统调用类的指令/广义指令）

   系统中用来登记状态信息的数据结构：作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲器、空闲区登记表、内存分配表等。

   对这些数据结构的常见操作：
   
   ① 进程管理（进程状态管理、进程调度和分派、创建与撤销进程控制块等）
   ② 存储器管理（存储器的空间分配和回收、内存信息保护程序、代码对换程序等）
   ③ 设备管理（缓冲区管理、设备分配和回收等）

可见，核心态指令实际上包括系统调用类指令和一些针对时钟、中断、原语的操作指令。

操作系统除内核以外的组件便是系统调用，内核提供了一系列具备预定功能的内核函数，通过系统调用呈现给用户。

:warning:操作系统只有内核部分常驻内存，其他部分仅在需要时才调入。

### 中断与异常

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20240809220756308.png" width="350px"/></dev>

**<u>中断的功能</u>**

早期的中断技术是为了处理数据传送，随着计算机的发展，中断技术不断被赋予新的功能，主要功能有：

1. 实现 CPU 与 I/O 设备的并行工作。
2. 处理硬件故障和软件错误。
3. 实现人机交互，用户干预机器需要用到中断系统。
4. 实现多道程序、分时操作，多道程序的切换需借助中断系统。
5. 实时处理需要借助中断系统来实现快速响应。
6. 实现应用程序和操作系统（管态程序）的切换。
7. 多处理器系统中各处理器之间的信息交流和任务切换。

**<u>异常和中断处理的大致过程</u>**

当 CPU 在执行当前程序或任务（即用户进程）的第 $i$ 条指令时检测到一个异常事件，或在执行第 $i$ 条指令后发现有一个中断请求信号，则 CPU 会打断当前用户进程，然后转到相应的异常或中断处理程序去执行。若异常或中断处理程序能够解决相应问题，则在异常或中断处理程序的最后，CPU 通过执行 “异常/中断返回指令” 回到被打断用户进程的第 $i$ 条或第 $i+1$  条指令继续执行；若异常或中断处理程序发现是不可恢复的致命错误，则终止用户进程。

通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。

**<u>中断和异常的区分</u>**

1. 是同步事件还是异步事件？同步事件是异常，异步事件是中断。
2. 来自处理机内部还是处理机外部？来自处理机内部是异常，来自处理机外部是中断。

#### 异常/内中断

异常(exception)：处理器执行一条指令时，由处理器在其**内部**检测到的、与正在执行的指令相关的**同步**事件。

**<u>异常的特点</u>**

1. 异常的检测是由 CPU 自身完成，不必通过外部信号通知 CPU。
2. 内部异常的响应发生在指令执行过程中。
3. 异常不能被屏蔽，一旦出现立即处理。
4. 异常与 CPU 同步，基本上发生在用户态，而执行/处理在核心态（核心态唯一发生的异常是 “缺页异常”）。

**<u>按原因分类</u>**

1. 硬故障中断

   由硬连线出现异常引起。

   如：控制器出错、存储器校验错、总线错误等。

2. 程序性异常

   在 CPU 内部因执行指令而引起的异常事件。

   如***<u>整</u>***除 0、溢出、断点、单步跟踪、非法操作码、段故障（地址越界和访问越权）、缺页故障、栈溢出、**分时系统中的时间片中断**​​等。

:warning:除数为 0 的处理：根据是定点除法指令还是浮点除法指令有不同的处理方式。对于浮点数除 0，异常处理程序可以选择将指令执行结果用特殊值表示（如 $\infin$ 或 NaN），然后返回到用户进程继续执行除法指令的下一条指令；而对于整除 0，则会发生 ”整除 0“ 故障，通常调用 abort 例程来终止当前用户进程。

:warning:浮点数运算下溢的处理：当作机器零处理，不需要异常处理。

:warning:分时系统中的时间片中断属于程序性异常中的陷阱。

**<u>按发生异常的报告方式和返回方式不同分类</u>**


1. **故障(Fault)**

   由**正在执行**的指令产生的异常事件（指令启动后、执行结束前被检测到）。

   如：指令译码时出现非法操作码、取数据时页故障、执行整数除法指令时发现除数为 0 等。

   有的故障异常处理后可回到发生故障的指令即**当前指令**继续执行 （如缺段、缺页）；有的则必须**终止**进程的执行，因为无法通过异常处理程序恢复 （如非法操作码、整除 0）。

   :seedling:<u>页故障（page fault）</u>：CPU 产生的 “page fault” 异常中包含了多种不同情况，需要页故障处理程序根据具体情况进行不同处理：首先检测是否发生地址越界或访问越权，如果是的话，则故障不可恢复；否则是真正的缺页故障，此时，可以通过从硬盘读入页面来恢复故障。Linux 中，不可恢复的访存故障（地址越界和访问越权）都称为段故障(segmentation fault)。

2. **自陷/陷阱/陷入(Trap)**

   人为预先设定的一种 “异常” 事件，不是出现某些异常情况而产生的。

   在程序中事先设定一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个 “陷阱”，当执行到被设置了 “陷阱” 的指令时，CPU 在执行完该指令后，根据不同的 “陷阱” 类型，无条件或有条件地（考题一般默认无条件地）转到相应的内核程序进行处理。处理完后，再返回 “陷阱” 指令的**下一条指令**执行（当 “陷阱” 是转移指令时，是返回到转移目标指令执行）。

   这种被设置了 “陷阱” 的特殊指令称为自陷指令/陷阱指令/访管指令（访问管理程序）。

   如：x86 机器中的程序调试功能（调试断点、单步跟踪）、条件自陷指令（如 MIPS 中的 teq、teqi、tne、tnei 等）、系统调用指令（如 x86 中的 `int 0x80` 或 `sysenter`）。

   :anchor:系统调用指令 ≠ 系统调用服务例程指令，系统调用指令是调用系统调用服务的指令。

   虽然内核实现了很多不同的系统调用，但是系统调用处理函数一般只有一个（如 Linux 中的 `system_call`）。 因此用户进程必须传递一个参数用于区分，这便是系统调用号。 在 Linux 中， 系统调用号一般通过 eax 寄存器来传递。

   <u>*访管中断*</u>：使用访管指令产生的自愿中断。用户程序在用户态下要使用特权指令引起的中断属于访管中断。

   在 IA-32 中，自陷指令引起的异常称为*<u>编程异常</u>*。这些指令包括 `int n`、`int3`、`into` (溢出检查)、`bound` (地址越界检查) 等。通常将 `int n` 称为软中断指令（`n` 为 8 位立即数，表示 256 种中断），执行该指令引起的 “异常” 通常也称为<u>*软中断*</u>。在 IA-32 + Linux 系统中，可以使用软中断指令 `int 0x80` 或快速系统调用指令 `sysenter` （不同处理器架构下）来进行系统调用。

   陷阱的两个重要作用：

   1）系统调用

   操作系统提供给用户程序调用的接口，用户程序通过接口来获得操作系统内核提供的服务。

   操作系统给每个系统调用编一个号，称为<u>系统调用号</u>，每个服务功能通过一个对应的系统调用服务例程提供。

   2）程序调试

   包括设置断点、单步跟踪。

   断点：通过插入断点指令 `int3` 实现，执行这条指令会产生一个中断类型号为 3 的异常，从而转去执行特定的异常处理程序。

   单步跟踪：x86 处理器中的 PSW 寄存器中，有一个陷阱标志位 TF (Trap Flag)。当 TF = 1时，CPU 每执行一条指令便会产生一个中断类型号为 1 的异常，从而转去执行特定的异常处理程序。也就是说，当 CPU 处于单步跟踪状态时（即 TF = 1），每条指令都被设置成了陷阱指令。

3. **终止(Abort)**

   在**执行指令过程中**发生了严重错误，使程序无法继续执行，只能**终止**发生问题的进程，在有些严重的情况下甚至要重启系统（通过中断服务程序）。

   如：控制器出错、访问 DRAM 或 SRAM 时发生校验错等。

   随机发生，不是由特定指令产生的，无法确定发生异常的是哪条指令。

:gun:故障异常和自陷异常属于程序性中断（软件中断），终止异常和外中断属于硬件中断。


#### 中断/外中断
来自 CPU（和主存）外部、与当前 CPU 正在执行的指令无关的异步事件引起的中断(Interruption)。

**<u>中断的大致工作流程</u>**

外部 I/O 设备通过特定的中断请求信号线向 CPU 提出中断请求，CPU 每执行完一条指令就检查中断请求信号线，如果检测到中断请求，则进入中断（响应）周期。

**<u>中断的类型</u>**

1. I/O 设备发出的 I/O 中断（如键盘输入、打印机缺纸等）。
2. 各种定时器引起的时钟中断。
3. ……

**<u>中断的分类</u>**

1. 可屏蔽中断

   指通过可屏蔽中断线 INTR (Interrupt Require) 向 CPU 发出的中断请求。

   CPU 可以通过在中断控制器（的屏蔽字寄存器）中设置相应的屏蔽字来屏蔽它或不屏蔽它，被屏蔽的中断请求将不被送到 CPU。

   通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。

2. 不可屏蔽中断

   指通过专门的不可屏蔽中断请求线 NMI (NonMaskable Interrupt) 向 CPU 发出的中断请求。

   通常用于处理紧急和重要的事件，如时钟中断、电源掉电等，其响应优先级最高（不可屏蔽中断 > 内部异常 > 可屏蔽中断）。

   这类中断请求信号不可被屏蔽（关中断没用），以让 CPU 快速处理这类紧急事件。

**<u>外中断 vs 内部异常</u>**

1. 异常事件是由特定指令在执行过程中产生的；而中断不和任何指令相关联，也不阻止任何指令的完成。

2. 异常的检测由 CPU 自身完成，不必通过外部某个信号通知 CPU；而对于中断，CPU 必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。

**<u>异常或中断的处理过程</u>**

每种处理器架构都会各自定义它所处理的异常和中断类型，而且对于异常和中断的处理，不同处理器/操作系统平台可能也有所不同，但是它们之间的差别不大，基本原理相同。

1. 关中断

   如果中断处理程序在保存原被打断程序现场的过程中又发生了新的中断，那么就会因为要处理新的中断，而把原被打断程序的现场以及已保存的断点和程序状态等破坏掉，因此应有一种机制来禁止在处理中断时再响应新的中断，即关中断。

   在 IA-32 中，CPU 在中断响应过程中会将标志寄存器 EFLAGS 中的 IF 清 0，以禁止响应新的可屏蔽中断。

2. 保存 <u>断点</u> 和 <u>程序状态字</u> 到内核栈或特定寄存器中（有时会将返回地址和 PSW 统称为断点）

   为了能支持异常或中断的嵌套处理，大多数处理器将断点保存在内核栈中，如 IA-32 处理器；如果硬件不支持嵌套处理，则可以将断点保存在特定寄存器中，如 MIPS 处理器。显然后者对于中断响应的开销较小，因为访问内核栈就是访问存储器，它比访问寄存器所用的时间要长。

   此外，MIPS 处理器没有 PSW，故只用保存 PC 到特定寄存器中。

   对于不同的异常事件，其返回地址（即断点）不同，数据通路必须能正确计算断点处的地址。

3. 引出中断服务程序

   识别中断源，取出对应的中断服务程序入口地址并送入 PC。

   通常有两种方法寻址中断服务程序的入口地址：硬件向量法/软件查询法。异常大多采用软件查询法，而中断可以采用软件查询法或硬件向量法。

4. 保存现场和旧中断屏蔽字（单重中断不用保存旧屏蔽字）

   现场指用户可见的工作寄存器内容，存放着程序执行到断点处的现行值（主要是通用寄存器和段寄存器的内容）。

   现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到中断栈/内核栈中（即由软件实现）。

   > 进程陷入内核态时，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后进行中断处理时，也需要中断栈来支持函数调用。由于中断处理时系统处于内核态，所以中断栈也可以和内核栈共享。是否共享具体要看处理器架构和操作系统平台的实现。

5. 设置新屏蔽字（单重中断略过）

6. 开中断（单重中断略过）

   允许更高级中断请求得到响应，实现中断嵌套。

7. 执行中断服务例程

   中断处理的主体部分，执行对应的中断服务例程 ISR (Interrupt Service Routine)，以完成设备的中断请求。

   以 I/O 中断为例：首先从设备控制器中读出设备状态，以判别本次中断是正常完成中断还是异常结束中断。若是前者，ISR 便做结束处理。假如这次是字符设备的读操作，则来自输入设备的中断是表明该设备已经读入了一个字符（字）的数据，并已放入 I/O 接口的数据寄存器中。此时 ISR 应将数据传送给 CPU 寄存器，再将数据从寄存器存入内存缓冲区中，并修改相应的缓冲区指针，使其指向下一个内存单元。若还有命令，可再向控制器发送新的命令，进行新一轮的数据传送；若是异常结束中断，则根据发生异常的原因做相应的处理。

8. 关中断（单重中断略过）

   保证在恢复现场和屏蔽字时不被中断。

9. 恢复现场和旧屏蔽字（单重中断不用恢复旧屏蔽字）

10. 清除中断请求

11. 开中断

12. 中断返回

    中断服务程序的最后一条指令通常是中断返回指令，通过中断返回指令回到断点处。

    中断返回指令的主要功能：恢复 PC 和 PSW、内核态 → 用户态、内核栈 → 用户栈。

:warning:注意点：

+ 1\~3 步由硬件自动完成（中断隐指令），是不可被打断的，主要目的是为了保证系统运行**可靠**、正确。提高处理速度也是一个好处，但不是主要目的。属于中断（响应）周期。
+ 4\~12 步均属于中断服务程序（操作系统内核），其中第 7 步是调用对应的 ISR（同样属于内核）去执行。
+ 整个中断过程是由软/硬件协同实现的。
+ 注意两次关中断的不同。

**<u>中断处理 vs 子程序调用</u>**

1）子程序和主程序是同一程序的两部分，属于主从关系；中断处理程序和当前程序相互独立。

2）子程序调用通过调用指令 CALL 引起的，是由程序设计者事先安排的；中断的产生通常都是随机的。

3）调用子程序的过程完全属于软件处理过程；中断的过程还需要专门的硬件电路才能实现。

4）子程序的入口地址是由 CALL 指令中的地址码给出的；中断处理程序的入口地址除了软件查询法，还可由硬件向量法产生向量地址，再由向量地址找到入口地址。

5）调用子程序和中断处理程序都需要保护 PC 内容，前者由 CALL 指令完成，后者由中断隐指令完成。

6）响应中断时，需对同时检测到的多个中断请求进行裁决，而调用子程序没有这种操作。

**<u>时钟中断</u>**

+ 主要工作

  处理和时间有关的信息及决定是否执行调度程序。

  和时间有关的信息：系统时间、进程的时间片、延时、使用 CPU 的时间、各种定时器。

+ 主要功能

  1）计时（第一功能）

  2）通过时钟管理，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。

+ 具体来说，时钟中断服务程序更新了：

  1）内核中时钟变量的值；

  2）当前进程占用 CPU 的时间；

  3）当前进程在时间片内的剩余执行时间。

+ 需要硬件计数器保持时钟的运行。
+ 时钟中断属于**可屏蔽**中断。

### 系统调用

系统调用是指用户在程序中调用操作系统所提供的一些子功能，可被视为特殊的公共子程序。

在用户程序中，凡是与资源有关的操作（如存储分配、I/O 传输及管理文件等）都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

通常一个操作系统提供的系统调用命令有几十条乃至上百条之多。

每个系统调用都有唯一的系统调用号。

系统调用需要触发陷入指令。

**<u>系统调用的功能</u>**

+ 设备管理：完成设备的请求或释放，以及设备启动等功能。
+ 文件管理：完成文件的读、写、创建及删除等功能。
+ 进程控制：完成进程的创建、撤销、阻塞及唤醒等功能。
+ 进程通信：完成进程之间的消息传递或信号传递等功能。
+ 内存管理：完成内存的分配、回收以及获取作业占用内存区大小和起始地址等功能。

显然，系统调用的处理需要由操作系统内核程序负责完成，要运行在内核态。

**<u>执行系统调用过程</u>**

传递系统调用号和参数 → 执行 trap 指令 → 执行相应服务程序 → 返回用户态

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220902113244088.png" width="550px"/></dev>

1. 传递系统调用参数

   用户程序首先将系统调用号和参数压入寄存器或堆栈中。

   Linux 使用若干传送指令把系统调用所需要的参数传送到相应的寄存器，按照惯例，系统调用号存放在 EAX 中，传递参数的寄存器顺序依次为：EAX（调用号）、EBX、ECX、EDX、ESI、EDI 和 EBP，除调用号外，最多 6 个参数。若参数个数超出寄存器个数，则将参数块所在存储区的首址放在寄存器中传递。

2. 执行 trap 指令

   执行到陷阱指令（如 `int 0x80`）触发中断，引起模式切换（陷入内核），然后便转到<u>系统调用处理程序</u>（如 `system_call`）开始执行。

   在 Linux 中，有一个系统调用的统一入口，即系统调用处理程序 `system_call` 的首地址，所以 CPU 执行陷阱指令 `int 0x80` 后，便转到系统调用处理程序 `system_call` 的第一条指令开始执行。

3. 执行相应服务程序

   系统调用作为一种特殊的 “异常事件”，<u>系统调用处理程序</u>也像其他异常处理程序一样，首先都是要保护现场。

   接着，系统调用处理程序根据系统调用号查找系统调用跳转表，转入相应的<u>系统调用服务例程</u>去执行。

4. 返回用户态

   系统调用处理程序执行完后，恢复被中断的或设置新进程的 CPU 现场，然后返回被中断进程（陷阱指令后面一条指令）或新进程，继续往下执行。

**<u>程序接口/应用编程接口 API (Application Programming Interface)</u>**

应用程序不直接使用内核提供的系统调用，而是使用 API。

API 和系统调用没有对应关系：API 可以由 1 个或多个系统调用实现，也可以完全不用。

API 可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，但本身在这些系统上的实现却可能迥异。

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220902173143818.png" width="400px"/></dev>

## 操作系统结构

### 分层法

最底层为硬件，最高层为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）。

下面一种依据与硬件关联紧密的程度的分法：

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230902180906652.png" width="400px"/>

<b><u>优点</u></b>

1. 便于系统调试和验证，简化系统的设计和实现

   自下而上逐层调试，每层调试完且验证正确后再向上调试。这样调试到某层发现错误时，此错误就应该源于该层，因为它的低层都调试好了。

2. 易扩充和易维护

   在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应的层间接口，就不会影响其他层。

**<u>存在问题</u>**

1. 合理定义各层比较困难（:warning:最显著不足）

   因为依赖关系固定后往往显得不够灵活。

2. 效率较差

   操作系统每执行一个功能通常要自上而下穿越多层，各层之间都有相应的层间通信机制，这无疑增加了额外的开销。

### 模块-接口法

将操作系统按功能划分为若干具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好各子模块之间的接口。这种设计方法被称为模块-接口法。

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230618153222768.png" width="550px"/></dev>

<u>**模块划分**</u>

模块太小虽能降低模块本身的复杂性，但会使得模块间的联系过多，造成系统比较混乱；模块太大又会增加内部复杂性。显然应在两者间进行权衡。

此外，划分模块时要充分考虑模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。

**<u>衡量模块独立的标准</u>**

+ 内聚性（模块内部各部分间联系的紧密程度）
+ 耦合度（模块间相互联系和相互影响的程度）

高内聚、低耦合 → 模块独立性好:relaxed:

**<u>模块化的优点</u>**

+ 提高了操作系统设计的正确性、可理解性和可维护性。

+ 增强了操作系统的可适应性。

  很多模块化的操作系统，可以支持动态加载新模块到内核。

+ 加速了操作系统的开发过程。

<u>**模块化的缺点**</u>

+ 模块间的接口规定很难满足对接口的实际需求。
+ 各模块设计者齐头并进地进行功能迭代，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。

### 宏内核/单内核/大内核

从操作系统的内核架构来分，可分为宏内核和微内核。

宏内核是指将操作系统的主要功能模块都作为一个联系紧密的整体运行在核心态，从而为用户程序提供高性能的系统服务。

<u>**优点**</u>

+ 系统的效率相对较高：因各管理模块之间共享信息，能有效利用相互之间的有效特性，进而为应用提供高性能的系统服务（不用通信）。

+ 接口简单直接。

<u>**缺点**</u> 

面临 “软件危机” 困境：复杂性随着系统规模增大而迅速增长，高耦合导致可移植性、可适应性较差，难以维护。

目前主流的桌面操作系统都是基于宏内核的构架，不过早已不是当年纯粹的宏内核构架，而是广泛吸取微内核构架优点后揉合而成的混合内核。

当今宏内核构架遇到了越来越多的困难和挑战，而微内核的优势似乎越来越明显。

### 微内核
内核只保留最基本功能（如进程管理等），将其他服务尽可能从内核中分离出去（将不需要再核心态执行的功能移到用户态执行），从而降低内核的设计复杂性。

移出内核的操作系统代码（根据分层的原则？）划分成若干服务程序，形成 C/S 模式。这些服务器进程的执行相互独立，交互则都借助于微内核进行通信。

<u>**定义微内核结构 OS 的四个方面**</u>

1. 足够小的内核。
   
2. 基于客户/服务器模式。
   
3. 应用 “机制与策略分离” 原理。
   
4. 采用面向对象技术（“抽象”、“隐蔽”、“封装”、“继承”）。

**<u>微内核架构下的操作系统组成</u>**

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220904093052783.png" width="500px"/></dev>

+ 微内核（核心态）

  ① 与硬件处理紧密相关的部分；②一些较基本功能；③客户和服务器之间的通信。

+ 多个服务器（用户态）

  操作系统中的绝大部分功能都放在微内核外的一组服务器（进程）中实现。
  
  客户与服务器之间借助微内核提供的消息传递机制来实现交互：
  
  <div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220904104606465.png" width="400px"/></dev>

在微内核结构中，为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块中的错误只会使这个模块崩溃，而不会使整个系统崩溃。


**<u>“机制与策略分离” 原理</u>**

在传统 OS 中，将机制放在 OS 内核的较低层中，把策略放在内核的较高层中。而微内核结构通常利用 “机制与策略分离” 的原理来构造 OS 结构，只将机制部分以及与硬件紧密相关的部分放入微内核。

机制：指实现某一功能的具体执行机构。

策略：指在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。

简单来说，机制决定如何做（how），而策略决定做什么（what），类似底层牛马码农和产品/项目经理的关系。

微内核操作系统将进程管理、存储器管理以及 I/O 管理这些功能一分为二，属于机制的很小一部分放入微内核，而绝大部分放入微内核外的各种服务器实现，大多数服务器都要比微内核大。因此，在采用 C/S 模式时，能将微内核做得很小。

<u>**微内核的基本功能**</u>

1. 进程（线程）管理

   机制部分：通信、调度、切换、多处理机间的同步等（微内核）。

   策略部分：对用户进程进行分类、优先级的确认方式等（进程管理服务器）。

2. 低级存储器管理

   机制部分：页表机制、地址变换机制等（微内核）。

   策略部分：实现虚拟存储器管理的策略 ，包含采取何种页面置换算法，采取何种内存分配与回收策略（存储器管理服务器）。

3. 中断和陷入处理

   机制部分：捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入事件后，再发送给相关的服务器来处理（微内核）。
   
   策略部分：具体的中断服务（相关服务器）。

**<u>微内核的优点</u>**

+ 可靠性和安全性

+ 扩展性和灵活性

  当要修改某些功能或增加某些新功能时，只需在相应的服务器中修改或增加新功能，或再增加一个专用的服务器，而无需改动内核代码。

+ 可移植性

  与 CPU 和 I/O 硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因而将 OS 移植到另一个平台上所需做的修改是比较小的。

+ 分布式计算

  客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，可以很方便地实现进程间的通信和同步，支持服务器之间的消息传递和远程过程调用，使得微内核系统能很好地支持分布式系统和网络系统。

**<u>微内核的缺点</u>**

主要问题是性能问题。因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大，导致执行效率较差。为了改善运行效率，可以将那些频繁使用的系统服务移回内核，从而保证系统性能，但这又会使微内核的容量明显增大。

另外，各服务器间的交互都借助于微内核进行通信，也影响了系统的效率。

**<u>微内核的应用场景</u>**

微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。

### 外核

一种比较少见的操作系统结构，由内核和外核(exokernel)两个部分组成。外核是一种运行在内核态的程序，它的任务是为用户进程/虚拟机分配未经抽象的硬件资源，并负责保证资源使用安全；内核部分只负责进程调度、进程通信等和硬件资源无关的功能。

**<u>策略</u>**

对机器进行划分，给每个用户分配整个资源的一个子集（不同于虚拟机克隆真实机器）。

**<u>优点</u>**

+ 外核可直接给用户进程分配 “不虚拟、不抽象” 的硬件资源，使用户可以更灵活地使用硬件资源。

+ 减少了虚拟硬件资源的 “映射层”，提升效率。

  在其他的设计中，每个虚拟机都认为它有自己的磁盘（或其他资源），这样虚拟机监控程序就必须维护一张表格以重咉像磁盘地址。有了外核，这个重映射处理就不需要了，外核只需记录已经分配给各个虚拟机的有关资源即可。

+ 将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应的负载并不重，因为外核所做的只是保持多个虚拟机彼此不发生冲突。

## 操作系统引导

操作系统引导是指计算机利用 CPU 运行特定程序，通过程序识别硬件、识别硬盘分区、识别硬盘分区上的操作系统，最后通过程序启动操作系统，一环扣一环地完成上述过程。

<u>**BIOS (Basic Input/Output System)**</u>

基本输入/输出系统，固化到主板 ROM 芯片上的一组程序。

是针对具体的主板设计的，与安装的操作系统无关。

BIOS 中包含了各种基本设备的驱动程序，通过执行 BIOS 程序，这些基本设备驱动程序以中断服务程序的形式加载到内存中，以提供基本 I/O 系统调用。

主要功能：在通电启动阶段执行硬件初始化，以及为操作系统提供运行时服务。具体包括：开机自检(POST)、BIOS 设置 / CMOS 设置、加载引导程序、BIOS 驱动程序。

**<u>常见操作系统引导过程</u>**

1. 激活 CPU

   激活的 CPU 读取 ROM 中的 boot 程序（BIOS），将指令寄存器置为 BIOS 的第一条指令，即开始执行 BIOS 的指令（CPU 加电 → CS:IP 指向 FFFF0H → 执行 JMP 指令跳到 BIOS）。

   > 引导在英文中为 “boot”，是 bootstrap 的缩写，源自于短语 “Pull oneself up by one's bootstraps”，即 “靠自己振作起来”（没用的知识增加了!）。

2. 硬件自检/通电自检/上电自检 POST (Power On Self Test)

   启动 BIOS 程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止；如无故障，屏幕会显示 CPU、内存、硬盘等信息。

   在硬件自检之前，BIOS 会在主存创建中断向量表（登记 BIOS 中断服务程序入口地址）和中断服务程序，以实现硬件自检。利用这些中断服务程序可以把操作系统内核程序（如主引导程序）从磁盘加载到内存中。BIOS 中各种基本设备的驱动程序也以中断服务程序的形式加载到内存中。

3. 加载带有操作系统的硬盘（BIOS 自举程序）

   硬件自检后，BIOS 开始读取启动顺序项 Boot Sequence（通过 CMOS 芯片里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备，然后 CPU 将该存储设备引导扇区的内容加载到内存中。

   硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。

4. 加载主引导记录 MBR (Master Boot Record)

   MBR 又叫做主引导扇区，其主要作用是告诉 CPU 去硬盘的哪个主分区去找操作系统。

   主引导扇区在硬盘上的三维地址为 (柱面, 磁头, 扇区) = (0, 0, 1)，即硬盘的第一个扇区。

   主引导扇区内部结构：开头 446 字节启动代码，其后 4 个 16 字节的磁盘分区表 DPT，以及 2 字节的结束标志。

   有时主引导记录特指主引导扇区的前 446 字节。

5. 扫描硬盘分区表，并加载硬盘活动分区

   MBR 硬盘分区表以特定的标识符区分活动分区和非活动分区。

   MBR 引导程序扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。

6. 加载分区引导记录 PBR

   读取活动分区的第一个扇区，这个扇区称为分区引导记录 PBR。

   寻找并激活分区根目录下（就在 PBR 中）用于引导操作系统的引导程序 —— 启动管理器。

   每个分区都有引导块，如果该分区没有安装操作系统，则该引导块内容为空。

   > 具有活动分区的引导硬盘又叫启动磁盘或系统磁盘，活动分区又叫启动分区，活动分区的引导块又叫启动块。

7. 加载启动管理器

   控制权给到启动管理器，以加载操作系统。

8. 加载操作系统

   将操作系统的初始化程序加载到内存中执行。
   
   :warning:注意：常驻内存的只是操作系统内核，其他部分仅在需要时才调入。​

<u>**CMOS (Complementary Metal Oxide Semiconductor)**</u>

主板上一块可读写的 RAM 芯片，用于保存当前系统的硬件配置信息和用户设定的某些参数。

BIOS 中存储的是程序，而 CMOS 中存储的是普通信息，且 CMOS 的內容在断电后会消失（系统故障时拿掉主板上的电池，进行 CMOS 放电操作，从而还原 BIOS 设置）。

<u>**各阶段的引导程序**</u>

1. 位于 ROM 中的自举程序（属于 BIOS），内容很少（为了避免改变自举代码而需要改变 ROM 硬件的问题），用于启动具体的存储设备，读入该设备主引导扇区 MBR 的引导代码。
1. 位于启动磁盘 MBR 中的引导程序，用于识别活动分区，读取活动分区的引导块 PBR。
1. 位于活动分区根目录下（PBR 中）的引导程序，称为启动管理器，用于加载操作系统。

实际上启动管理器才是操作系统的引导程序。

## 虚拟机

使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器 VM (Virtual Machine)，每个虚拟机器都可以独立运行一个操作系统。

虚拟机是一台逻辑计算机，利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。

有两类虚拟化方法，对应两类虚拟机管理程序 VMM (Virtual Machine Monitor)。

<u>**第一类 VMM**</u>

第一类 VMM 直接运行在硬件上，是唯一运行在内核态的程序（就像一个操作系统），它在裸机上运行并且具备多道程序功能。

VMM 向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220904151649323.png" width="450px"/></dev>

虚拟机作为用户态的一个进程运行，不允许执行敏感指令，而虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。虚拟机中的用户进程认为自己运行在用户态（实际上确实是）。

当虚拟机操作系统执行了一条 CPU 处于内核态才允许执行的指令时，会陷入 VMM：

+ 在支持虚拟化的 CPU 上，VMM 检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，VMM 将安排这条指令功能的正确执行。否则，VMM 将模拟真实硬件面对用户态要执行敏感指令时的行为。
+ 在过去不支持虚拟化的 CPU 上，真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对 VMM 的调用，由 VMM 模拟这些指令的功能。

支持虚拟化的 CPU 通常分更多指令等级。

<u>**第二类 VMM**</u>

第二类 VMM 运行在宿主操作系统上，是一个依赖宿主操作系统分配和调度资源的程序，但仍伪装成具有 CPU 和各种设备的完整计算机。

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20220904152839488.png" width="400px"/></dev>

在首次创建虚拟机时，会将该虚拟机的操作系统安装在虚拟磁盘上（其实只是宿主操作系统的一个文件）。客户操作系统安装完成后就能启动并运行。

:warning:真实硬件不会直接执行虚拟机中的敏感指令，而是由第二类 VMM 模拟真实硬件环境。

VMware Workstation 是首个 x86 平台上的第二类 VMM。

<u>**两类 VMM 对比**</u>

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/vmm22.png" width="600px"/></dev>

运行在两类虚拟机管理程序上的操作系统都称为<u>客户操作系统</u>。

有的教材将第一类虚拟化技术称为<u>裸金属架构</u>，将第二类虚拟化技术称为<u>寄居架构</u>。

**<u>应用场景</u>**

虚拟化在 Web 主机领域很流行，市面上常见的云主机就是服务商提供租用的虚拟机。没有虚拟化，服务商就只能提供共享托管和独占托管。

## 刷题总结

+ 甘特图/横道图

  <div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20240805103738833.png" width="600px"/></dev>

+ 注意模块化系统和微内核系统（优缺点和通信方式）不要搞混。

  可扩展性应该是二者唯一的共同特性，只不过在模块化系统那里叫可适应性。
  
+ 被中断程序本身可能是用户程序，但是进入中断的处理程序一定是操作系统程序。
