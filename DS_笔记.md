栈的数学性质：出栈排列数目满足函数 $Catalan()$：$N=\frac{1}{n+1}C^n_{2n}$（$n$ 个不同元素以某种顺序依次进栈，并可在任意时刻出栈，且满足 FILO）

给定 $n$ 个结点的先序序列，可以构成 $h(n)=\frac{C^n_{2n}}{n+1}$ 种不同的二叉树

### 二叉树

完全二叉树的高度为 $\left\lceil\log_{2}(n+1)\right\rceil$ 或 $\left\lfloor\log _2 n\right\rfloor+1$

### 外部排序

假定：$n$ 个元素，$r$ 个初始归并段，$k$ 路归并

利用简单选择排序做内部归并时，在 $k$ 个元素中选择最小记录需要比较 $k-1$ 次，每趟归并需要比较 $(n-1)(k-1)$ 次，$S$ 趟归并需要比较的次数为：$S(n-1)(k-1)=\left\lceil\log _k r\right\rceil(n-1)(k-1)=\left\lceil\log _2 r\right\rceil(n-1)(k-1) /\left\lceil\log _2 k\right\rceil$

利用败者树做内部归并时，在 $k$ 个元素中选择最小记录需要比较 $\left\lceil\log _2 k\right\rceil$ 次，每趟归并需要比较 $(n-1)\left\lceil\log _2 k\right\rceil$ 次，$S$ 趟归并需要比较的次数为：$S(n-1)\left\lceil\log _2 k\right\rceil=\left\lceil\log _k r\right\rceil(n-1)\left\lceil\log _2 k\right\rceil=(n-1)\left\lceil\log _2 r\right\rceil$

最佳归并树是 $k$ 叉哈夫曼树，满足 $n_0=(k-1) n_k+1$
$\left(n_0-1\right) \%(k-1)=u$，$u$ 为多余的叶结点，需要加上 $k-1-u$ 个虚段（空归并段）才可建立归并树

## 查找

### 基本概念

+ 对查找表的操作
    1. 查询某个特定元素是否在查找表中
    2. 检索满足条件的某个特定的数据元素的各种属性
    3. 插入
    4. 删除
+ 静态查找表
    只涉及上述 1 和 2 操作
    适合静态查找表的查找方法：顺序查找、折半查找、散列查找
+ 动态查找表
    涉及到插入和删除操作的查找表
    适合动态查找表的查找方法：二叉排序树的查找、散列查找

+ 平均比较次数/平均查找长度 ASL
    $ASL = \sum^n_{i=1}p_i \times c_i$
    $n$ 为查找表记录个数/长度；$p_i$ 为查找第 i 个记录的概率，一般取 $\frac{1}{n}$；$c_i$ 为找到第 $i$ 个记录需要比较的次数
    $ASL$ 有两种：查找成功情况下的 $ASL1$、查找失败情况下的 $ASL2$

### 顺序查找

顺序链式都可

一般线性表的顺序查找：$\mathrm{ASL}_{\text {成功}}=\sum_{i=1}^n P_i(n-i+1)=\frac{n+1}{2}$，$\mathrm{ASL}_{\text {不成功 }}=n+1$

有序表的顺序查找：$\mathrm{ASL}_{\text {成功}}=\frac{n+1}{2}$，$\mathrm{ASL}_{\text {不成功 }}=\sum_{j=1}^n q_j\left(l_j-1\right)=\frac{1+2+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$

### 折半查找

有序+顺序

判定树是一颗平衡二叉树，有 $n$ 个非叶结点（成功结点）和 $n+1$ 个叶结点（失败结点）

<div align=left><img src="https://pic-zerooo.oss-cn-beijing.aliyuncs.com/ungee/image-20230318222812433.png" width="600px"/></dev>

$\mathrm{ASL}_{\text {成功}}=\frac{1}{n}\left(1 \times 1+2 \times 2+\cdots+h \times 2^{h-1}\right)=\frac{n+1}{n} \log _2(n+1)-1$，$\mathrm{ASL}_{\text {不成功 }}=\frac{1}{n+1}(h×(2^h-m)+(h+1)×2m)$

### 分块查找

块间有序，块内可无序

$ASL$ 为索引查找和块内查找的平均长度之和

理想块长为 $\sqrt{n}$

 ### 二叉排序树

#### 二叉排序树 vs 二分查找

相似点：平均时间性能差不多

不同点：
二分查找的判定树唯一，而二叉排序树的查找不唯一（相同关键字其插入顺序不同可能生成不同的二叉排序树）
就维护表的有序性而言，二叉排序树无需移动结点，只需修改指针即可完成插入和删除操作，平均执行时间为 $log_{2}n$；二分查找的对象是有序顺序表，插入删除操作代价是 $O(n)$、

当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构

### 平衡二叉树

为避免树的高度增长过快降低二叉排序树的性能，引入平衡二叉树/$AVL$ 树

$AVL$ 树是一棵特殊的二叉排序树，特点在于其任意结点的左右子树高度差（平衡因子）的绝对值不超过 1

以 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数，存在结论：$n_h=n_{h-1}+n_{h-2}+1$（$n_0=0$，$n_1=1$，$n_2=2$）

平衡二叉树满足平衡的最少结点的情况 = 所有非叶子结点的平衡因子均为 1

含有 $n$ 个结点的平衡二叉树的最大深度为 $O(log_{2}n)$，最理想深度 = 同结点数的完全二叉树的高度

### 红黑树

为保持 $AVL$ 树的平衡性，插入和删除操作后，非常频繁地调整全树整体拓扑结构，代价较大。为此在 $AVL$ 树的“高度平衡”的标准上进一步放宽条件，引入了“适度平衡”的红黑树

> 但红黑树和 $ASL$ 树查找、插入、删除的时间复杂度都相同

#### 性质

1. 特殊的二叉排序树
2. 每个结点非黑即红
3. 根结点是黑的
4. 叶结点（虚构的外部结点、NULL 结点）都是黑的
5. 不存在两个相邻的红结点（即红结点的父结点和孩子结点都是黑的）
6. 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同

> 从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为 bh）。根结点的黑高称为红黑树的黑高

#### 结论

从根结点到叶结点的最长路径不大于最短路径的 2 倍

有 $n$ 个内部结点的红黑树高度 $h \leqslant 2 \log _2(n+1)$ 

#### 插入

— 先查找，确定插入位置（原理同二叉排序树）
— 新结点是根 → 染黑
— 新结点非根 → 染红
—— 满足红黑树定义 → 插入结束
—— 不满足红黑树定义，需要调整
——— 黑叔：旋转 + 变色
———— LL 型 → 右单旋，父换爷 + 变色
———— RR 型 → 左单旋，父换爷 + 变色
———— LR 型 → 左右双旋，儿换爷 + 变色
———— RL 型 → 右左双旋，儿换爷 + 变色
——— 红叔 → 叔父爷变色，爷变为新结点（上移了两层，继续重复循环）

#### 删除

TODO

### B 树

+ 一棵 $m$ 阶 $B$ 树或为空树，或为满足如下特性的 $m$ 叉树：
  1. 所有结点的平衡因子均为 0 的 $m$ 路平衡查找树
  2. 每个结点至多 m 棵子树（至多含 m-1 个关键字）
  3. 除根结点外的所有分支结点至少 $\lceil m / 2\rceil$ 棵子树（至少含 $\lceil m / 2\rceil-1$ 个关键字）
  4. 非终端的根结点至少 2 棵子树（至少含 1 个关键字）
  5. 所有叶结点在同一层，不包含任何信息

+ B 树的高度
    规定 B 树高度不包括叶结点
    1. n ≤ (m-1)(1+m+$m^2$+…+$m^{h-1}$) = $m^h$ - 1
    h ≥ $\log_m(n+1)$
    2. n + 1 ≥ 2$(\lceil m / 2])^{h-1}$
    h ≤ $\log_{\lceil m / 2]}((n+1)/2)$ + 1
